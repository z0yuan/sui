<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/sui/sui/target/debug/build/sui-replay-2-b0c571849f67ffe3/out/cynic-schemas/rpc.rs`."><title>rpc.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../../../../../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../../static.files/" data-current-crate="sui_replay_2" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../../../../../../../../../../../static.files/storage-59e33391.js"></script><script defer src="../../../../../../../../../../../../../static.files/src-script-56102188.js"></script><script defer src="../../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../../../../../../../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../../../../../../../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">sui_replay_2/home/runner/work/sui/sui/target/debug/build/sui-replay-2-b0c571849f67ffe3/out/cynic-schemas/</div>rpc.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a></pre></div><pre class="rust"><code><span class="kw">impl </span>cynic :: schema :: QueryRoot <span class="kw">for </span>Query { } <span class="kw">pub struct </span>Addressable ; <span class="kw">pub struct </span>Base64 { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Base64 { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Base64" </span>; } <span class="kw">pub struct </span>BigInt { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>BigInt { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"BigInt" </span>; } <span class="kw">pub struct </span>Checkpoint ; <span class="kw">pub struct </span>CheckpointFilter ; <span class="kw">impl </span>cynic :: schema :: InputObjectMarker <span class="kw">for </span>CheckpointFilter { } <span class="kw">pub struct </span>DateTime { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>DateTime { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"DateTime" </span>; } <span class="kw">pub struct </span>Epoch ; <span class="kw">pub struct </span>FeatureFlag ; <span class="kw">pub struct </span>IAddressable ; <span class="kw">pub struct </span>IObject ; <span class="kw">pub struct </span>MovePackage ; <span class="kw">pub struct </span>MovePackageConnection ; <span class="kw">pub struct </span>MovePackageEdge ; <span class="kw">pub struct </span>Object ; <span class="kw">pub struct </span>ObjectChange ; <span class="kw">pub struct </span>ObjectChangeConnection ; <span class="kw">pub struct </span>ObjectChangeEdge ; <span class="kw">pub struct </span>ObjectConnection ; <span class="kw">pub struct </span>ObjectEdge ; <span class="kw">pub struct </span>ObjectKey ; <span class="kw">impl </span>cynic :: schema :: InputObjectMarker <span class="kw">for </span>ObjectKey { } <span class="kw">pub struct </span>PackageKey ; <span class="kw">impl </span>cynic :: schema :: InputObjectMarker <span class="kw">for </span>PackageKey { } <span class="kw">pub struct </span>PageInfo ; <span class="kw">pub struct </span>ProtocolConfig ; <span class="kw">pub struct </span>ProtocolConfigs ; <span class="kw">pub struct </span>Query ; <span class="kw">pub struct </span>ServiceConfig ; <span class="kw">pub struct </span>SuiAddress { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>SuiAddress { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"SuiAddress" </span>; } <span class="kw">pub struct </span>Transaction ; <span class="kw">pub struct </span>TransactionEffects ; <span class="kw">pub struct </span>UInt53 { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>UInt53 { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"UInt53" </span>; } <span class="kw">pub struct </span>VersionFilter ; <span class="kw">impl </span>cynic :: schema :: InputObjectMarker <span class="kw">for </span>VersionFilter { } # [allow (non_camel_case_types)] <span class="kw">pub struct </span>include ; <span class="kw">impl </span>cynic :: schema :: FieldDirective <span class="kw">for </span>include { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>str = <span class="string">"include" </span>; } # [allow (non_camel_case_types)] <span class="kw">pub mod </span>_include_arguments { <span class="kw">pub struct </span>r#if ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; r#if &gt; <span class="kw">for super </span>:: include { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: Boolean ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"if" </span>; } } # [allow (non_camel_case_types)] <span class="kw">pub struct </span>skip ; <span class="kw">impl </span>cynic :: schema :: FieldDirective <span class="kw">for </span>skip { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>str = <span class="string">"skip" </span>; } # [allow (non_camel_case_types)] <span class="kw">pub mod </span>_skip_arguments { <span class="kw">pub struct </span>r#if ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; r#if &gt; <span class="kw">for super </span>:: skip { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: Boolean ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"if" </span>; } } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; Addressable &gt; <span class="kw">for </span>IAddressable { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; IAddressable &gt; <span class="kw">for </span>IAddressable { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; IObject &gt; <span class="kw">for </span>IObject { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; MovePackage &gt; <span class="kw">for </span>IAddressable { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; MovePackage &gt; <span class="kw">for </span>IObject { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; Object &gt; <span class="kw">for </span>IAddressable { } <span class="kw">impl </span>cynic :: schema :: HasSubtype &lt; Object &gt; <span class="kw">for </span>IObject { } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Addressable { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Addressable" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Checkpoint { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Checkpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Epoch { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Epoch" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>FeatureFlag { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"FeatureFlag" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>IAddressable { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"IAddressable" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>IObject { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"IObject" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>MovePackage { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"MovePackage" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>MovePackageConnection { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"MovePackageConnection" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>MovePackageEdge { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"MovePackageEdge" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Object { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Object" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ObjectChange { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ObjectChange" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ObjectChangeConnection { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ObjectChangeConnection" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ObjectChangeEdge { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ObjectChangeEdge" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ObjectConnection { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ObjectConnection" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ObjectEdge { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ObjectEdge" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>PageInfo { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"PageInfo" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ProtocolConfig { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ProtocolConfig" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ProtocolConfigs { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ProtocolConfigs" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Query { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Query" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>ServiceConfig { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"ServiceConfig" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>Transaction { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"Transaction" </span>; } <span class="kw">impl </span>cynic :: schema :: NamedType <span class="kw">for </span>TransactionEffects { <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"TransactionEffects" </span>; } # [allow (non_snake_case , non_camel_case_types)] <span class="kw">pub mod </span>__fields { <span class="kw">pub mod </span>Addressable { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; address &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Addressable { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Addressable { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>Checkpoint { <span class="kw">pub struct </span>sequenceNumber ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>sequenceNumber { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"sequenceNumber" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; sequenceNumber &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Checkpoint { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>query ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Query &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"query" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; query &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Checkpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Query &gt; ; } <span class="kw">pub struct </span>epoch ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"epoch" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; epoch &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Checkpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; ; } <span class="kw">pub struct </span>timestamp ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>timestamp { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"timestamp" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; timestamp &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Checkpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Checkpoint { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>CheckpointFilter { <span class="kw">pub struct </span>afterCheckpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>afterCheckpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"afterCheckpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; afterCheckpoint , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: CheckpointFilter { } <span class="kw">pub struct </span>beforeCheckpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>beforeCheckpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"beforeCheckpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; beforeCheckpoint , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: CheckpointFilter { } } <span class="kw">pub mod </span>Epoch { <span class="kw">pub struct </span>epochId ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>epochId { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"epochId" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; epochId &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>coinDenyList ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>coinDenyList { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"coinDenyList" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; coinDenyList &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub struct </span>protocolConfigs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>protocolConfigs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfigs &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"protocolConfigs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; protocolConfigs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfigs &gt; ; } <span class="kw">pub struct </span>referenceGasPrice ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>referenceGasPrice { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: BigInt &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"referenceGasPrice" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; referenceGasPrice &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: BigInt &gt; ; } <span class="kw">pub struct </span>startTimestamp ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>startTimestamp { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"startTimestamp" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; startTimestamp &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; } <span class="kw">pub struct </span>systemPackages ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>systemPackages { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"systemPackages" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; systemPackages &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; } <span class="kw">pub mod </span>_system_packages_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: systemPackages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: systemPackages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: systemPackages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: systemPackages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } } <span class="kw">pub struct </span>endTimestamp ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>endTimestamp { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"endTimestamp" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; endTimestamp &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: DateTime &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Epoch { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>FeatureFlag { <span class="kw">pub struct </span>key ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>key { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"key" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; key &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: FeatureFlag { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>value ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>value { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"value" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; value &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: FeatureFlag { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: FeatureFlag { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>IAddressable { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; address &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IAddressable { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IAddressable { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>IObject { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>version { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; version &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>digest { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; digest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>objectAt ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectAt { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectAt" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectAt &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub mod </span>_object_at_arguments { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>rootVersion ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; rootVersion &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"rootVersion" </span>; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; checkpoint &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } } <span class="kw">pub struct </span>objectBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>objectVersionsAfter ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsAfter { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsAfter" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsAfter &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; } <span class="kw">pub mod </span>_object_versions_after_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>objectVersionsBefore ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsBefore { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsBefore" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsBefore &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; } <span class="kw">pub mod </span>_object_versions_before_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>previousTransaction ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>previousTransaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"previousTransaction" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; previousTransaction &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: IObject { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>MovePackage { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; address &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>version { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; version &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>digest { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; digest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>objectAt ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectAt { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectAt" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectAt &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub mod </span>_object_at_arguments { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>rootVersion ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; rootVersion &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"rootVersion" </span>; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; checkpoint &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } } <span class="kw">pub struct </span>objectBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>objectVersionsAfter ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsAfter { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsAfter" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsAfter &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; } <span class="kw">pub mod </span>_object_versions_after_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>objectVersionsBefore ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsBefore { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsBefore" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsBefore &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; } <span class="kw">pub mod </span>_object_versions_before_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>packageAt ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packageAt { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packageAt" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packageAt &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; } <span class="kw">pub mod </span>_package_at_arguments { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: packageAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; checkpoint &gt; <span class="kw">for super </span>:: packageAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } } <span class="kw">pub struct </span>packageBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packageBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packageBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packageBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>packageVersionsAfter ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packageVersionsAfter { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packageVersionsAfter" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packageVersionsAfter &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection ; } <span class="kw">pub mod </span>_package_versions_after_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: packageVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: packageVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: packageVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: packageVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: packageVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>packageVersionsBefore ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packageVersionsBefore { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packageVersionsBefore" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packageVersionsBefore &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection ; } <span class="kw">pub mod </span>_package_versions_before_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: packageVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: packageVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: packageVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: packageVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: packageVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>previousTransaction ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>previousTransaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"previousTransaction" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; previousTransaction &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>MovePackageConnection { <span class="kw">pub struct </span>pageInfo ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>pageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"pageInfo" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; pageInfo &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; } <span class="kw">pub struct </span>edges ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>edges { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageEdge &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"edges" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; edges &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageEdge &gt; ; } <span class="kw">pub struct </span>nodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>nodes { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"nodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; nodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>MovePackageEdge { <span class="kw">pub struct </span>node ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>node { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"node" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; node &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage ; } <span class="kw">pub struct </span>cursor ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>cursor { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"cursor" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; cursor &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: MovePackageEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>Object { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; address &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>version { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; version &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>digest { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; digest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>asMovePackage ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>asMovePackage { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"asMovePackage" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; asMovePackage &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; } <span class="kw">pub struct </span>objectAt ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectAt { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectAt" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectAt &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub mod </span>_object_at_arguments { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>rootVersion ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; rootVersion &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"rootVersion" </span>; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; checkpoint &gt; <span class="kw">for super </span>:: objectAt { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } } <span class="kw">pub struct </span>objectBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>objectVersionsAfter ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsAfter { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsAfter" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsAfter &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; } <span class="kw">pub mod </span>_object_versions_after_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsAfter { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>objectVersionsBefore ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersionsBefore { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersionsBefore" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersionsBefore &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection ; } <span class="kw">pub mod </span>_object_versions_before_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersionsBefore { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>previousTransaction ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>previousTransaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"previousTransaction" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; previousTransaction &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Object { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectChange { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; address &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; } <span class="kw">pub struct </span>inputState ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>inputState { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"inputState" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; inputState &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub struct </span>outputState ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>outputState { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"outputState" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; outputState &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub struct </span>idCreated ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>idCreated { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"idCreated" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; idCreated &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean &gt; ; } <span class="kw">pub struct </span>idDeleted ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>idDeleted { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"idDeleted" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; idDeleted &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChange { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectChangeConnection { <span class="kw">pub struct </span>pageInfo ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>pageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"pageInfo" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; pageInfo &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; } <span class="kw">pub struct </span>edges ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>edges { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChangeEdge &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"edges" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; edges &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChangeEdge &gt; ; } <span class="kw">pub struct </span>nodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>nodes { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChange &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"nodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; nodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChange &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectChangeEdge { <span class="kw">pub struct </span>node ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>node { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChange ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"node" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; node &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChange ; } <span class="kw">pub struct </span>cursor ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>cursor { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"cursor" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; cursor &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectChangeEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectConnection { <span class="kw">pub struct </span>pageInfo ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>pageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"pageInfo" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; pageInfo &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: PageInfo ; } <span class="kw">pub struct </span>edges ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>edges { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectEdge &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"edges" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; edges &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectEdge &gt; ; } <span class="kw">pub struct </span>nodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>nodes { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"nodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; nodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectConnection { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectConnection { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectEdge { <span class="kw">pub struct </span>node ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>node { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Object ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"node" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; node &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Object ; } <span class="kw">pub struct </span>cursor ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>cursor { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"cursor" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; cursor &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectEdge { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ObjectKey { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; address , <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectKey { } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>version { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; version , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectKey { } <span class="kw">pub struct </span>rootVersion ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>rootVersion { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"rootVersion" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; rootVersion , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectKey { } <span class="kw">pub struct </span>atCheckpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>atCheckpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"atCheckpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; atCheckpoint , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ObjectKey { } } <span class="kw">pub mod </span>PackageKey { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>address { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; address , <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PackageKey { } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>version { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; version , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PackageKey { } <span class="kw">pub struct </span>atCheckpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>atCheckpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"atCheckpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; atCheckpoint , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PackageKey { } } <span class="kw">pub mod </span>PageInfo { <span class="kw">pub struct </span>hasPreviousPage ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>hasPreviousPage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"hasPreviousPage" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; hasPreviousPage &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; } <span class="kw">pub struct </span>hasNextPage ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>hasNextPage { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"hasNextPage" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; hasNextPage &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: Boolean ; } <span class="kw">pub struct </span>startCursor ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>startCursor { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"startCursor" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; startCursor &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PageInfo { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; } <span class="kw">pub struct </span>endCursor ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>endCursor { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"endCursor" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; endCursor &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PageInfo { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: PageInfo { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ProtocolConfig { <span class="kw">pub struct </span>key ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>key { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"key" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; key &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfig { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>value ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>value { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"value" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; value &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfig { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ProtocolConfigs { <span class="kw">pub struct </span>protocolVersion ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>protocolVersion { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"protocolVersion" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; protocolVersion &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 ; } <span class="kw">pub struct </span>config ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>config { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfig &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"config" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; config &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfig &gt; ; } <span class="kw">pub mod </span>_config_arguments { <span class="kw">pub struct </span>key ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; key &gt; <span class="kw">for super </span>:: config { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"key" </span>; } } <span class="kw">pub struct </span>configs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>configs { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfig &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"configs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; configs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfig &gt; ; } <span class="kw">pub struct </span>featureFlag ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>featureFlag { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: FeatureFlag &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"featureFlag" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; featureFlag &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: FeatureFlag &gt; ; } <span class="kw">pub mod </span>_feature_flag_arguments { <span class="kw">pub struct </span>key ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; key &gt; <span class="kw">for super </span>:: featureFlag { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"key" </span>; } } <span class="kw">pub struct </span>featureFlags ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>featureFlags { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: FeatureFlag &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"featureFlags" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; featureFlags &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: FeatureFlag &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ProtocolConfigs { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>Query { <span class="kw">pub struct </span>chainIdentifier ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>chainIdentifier { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"chainIdentifier" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; chainIdentifier &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>checkpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; checkpoint &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; ; } <span class="kw">pub mod </span>_checkpoint_arguments { <span class="kw">pub struct </span>sequenceNumber ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; sequenceNumber &gt; <span class="kw">for super </span>:: checkpoint { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"sequenceNumber" </span>; } } <span class="kw">pub struct </span>epoch ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>epoch { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"epoch" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; epoch &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; ; } <span class="kw">pub mod </span>_epoch_arguments { <span class="kw">pub struct </span>epochId ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; epochId &gt; <span class="kw">for super </span>:: epoch { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"epochId" </span>; } } <span class="kw">pub struct </span>multiGetCheckpoints ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetCheckpoints { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetCheckpoints" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetCheckpoints &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_checkpoints_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetCheckpoints { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>multiGetEpochs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetEpochs { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetEpochs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetEpochs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Epoch &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_epochs_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetEpochs { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>multiGetObjects ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetObjects { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetObjects" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetObjects &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_objects_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetObjects { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectKey &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>multiGetPackages ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetPackages { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetPackages" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetPackages &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_packages_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetPackages { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: PackageKey &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>multiGetTransactions ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetTransactions { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetTransactions" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetTransactions &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_transactions_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetTransactions { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>multiGetTransactionEffects ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>multiGetTransactionEffects { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"multiGetTransactionEffects" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; multiGetTransactionEffects &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = Vec &lt; <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; &gt; ; } <span class="kw">pub mod </span>_multi_get_transaction_effects_arguments { <span class="kw">pub struct </span>keys ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; keys &gt; <span class="kw">for super </span>:: multiGetTransactionEffects { <span class="kw">type </span>ArgumentType = Vec &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"keys" </span>; } } <span class="kw">pub struct </span>object ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>object { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"object" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; object &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Object &gt; ; } <span class="kw">pub mod </span>_object_arguments { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; address &gt; <span class="kw">for super </span>:: object { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: object { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>rootVersion ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; rootVersion &gt; <span class="kw">for super </span>:: object { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"rootVersion" </span>; } <span class="kw">pub struct </span>atCheckpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; atCheckpoint &gt; <span class="kw">for super </span>:: object { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"atCheckpoint" </span>; } } <span class="kw">pub struct </span>objectVersions ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectVersions { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectVersions" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectVersions &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectConnection &gt; ; } <span class="kw">pub mod </span>_object_versions_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; address &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: objectVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>package ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>package { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"package" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; package &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackage &gt; ; } <span class="kw">pub mod </span>_package_arguments { <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; address &gt; <span class="kw">for super </span>:: package { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: package { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } <span class="kw">pub struct </span>atCheckpoint ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; atCheckpoint &gt; <span class="kw">for super </span>:: package { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"atCheckpoint" </span>; } } <span class="kw">pub struct </span>packages ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packages { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packages" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packages &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; } <span class="kw">pub mod </span>_packages_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: packages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: packages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: packages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: packages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: packages { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: CheckpointFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>packageVersions ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>packageVersions { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"packageVersions" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; packageVersions &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: MovePackageConnection &gt; ; } <span class="kw">pub mod </span>_package_versions_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } <span class="kw">pub struct </span>address ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; address &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: SuiAddress ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"address" </span>; } <span class="kw">pub struct </span>filter ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; filter &gt; <span class="kw">for super </span>:: packageVersions { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: VersionFilter &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"filter" </span>; } } <span class="kw">pub struct </span>protocolConfigs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>protocolConfigs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfigs &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"protocolConfigs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; protocolConfigs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ProtocolConfigs &gt; ; } <span class="kw">pub mod </span>_protocol_configs_arguments { <span class="kw">pub struct </span>version ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; version &gt; <span class="kw">for super </span>:: protocolConfigs { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"version" </span>; } } <span class="kw">pub struct </span>serviceConfig ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>serviceConfig { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ServiceConfig ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"serviceConfig" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; serviceConfig &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: ServiceConfig ; } <span class="kw">pub struct </span>transaction ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>transaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"transaction" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; transaction &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; } <span class="kw">pub mod </span>_transaction_arguments { <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; digest &gt; <span class="kw">for super </span>:: transaction { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } } <span class="kw">pub struct </span>transactionEffects ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>transactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"transactionEffects" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; transactionEffects &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; ; } <span class="kw">pub mod </span>_transaction_effects_arguments { <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; digest &gt; <span class="kw">for super </span>:: transactionEffects { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Query { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>ServiceConfig { <span class="kw">pub struct </span>mutationTimeoutMs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>mutationTimeoutMs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"mutationTimeoutMs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; mutationTimeoutMs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>queryTimeoutMs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>queryTimeoutMs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"queryTimeoutMs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; queryTimeoutMs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxQueryDepth ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxQueryDepth { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxQueryDepth" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxQueryDepth &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxQueryNodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxQueryNodes { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxQueryNodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxQueryNodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxOutputNodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxOutputNodes { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxOutputNodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxOutputNodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxTransactionPayloadSize ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxTransactionPayloadSize { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxTransactionPayloadSize" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxTransactionPayloadSize &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxQueryPayloadSize ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxQueryPayloadSize { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxQueryPayloadSize" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxQueryPayloadSize &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>defaultPageSize ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>defaultPageSize { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"defaultPageSize" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; defaultPageSize &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub mod </span>_default_page_size_arguments { <span class="kw">pub struct </span>r#type ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; r#type &gt; <span class="kw">for super </span>:: defaultPageSize { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"type" </span>; } <span class="kw">pub struct </span>field ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; field &gt; <span class="kw">for super </span>:: defaultPageSize { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"field" </span>; } } <span class="kw">pub struct </span>maxPageSize ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxPageSize { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxPageSize" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxPageSize &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub mod </span>_max_page_size_arguments { <span class="kw">pub struct </span>r#type ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; r#type &gt; <span class="kw">for super </span>:: maxPageSize { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"type" </span>; } <span class="kw">pub struct </span>field ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; field &gt; <span class="kw">for super </span>:: maxPageSize { <span class="kw">type </span>ArgumentType = <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"field" </span>; } } <span class="kw">pub struct </span>maxMultiGetSize ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxMultiGetSize { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxMultiGetSize" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxMultiGetSize &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxTypeArgumentDepth ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxTypeArgumentDepth { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxTypeArgumentDepth" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxTypeArgumentDepth &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxTypeArgumentWidth ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxTypeArgumentWidth { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxTypeArgumentWidth" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxTypeArgumentWidth &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxTypeNodes ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxTypeNodes { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxTypeNodes" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxTypeNodes &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>maxMoveValueDepth ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>maxMoveValueDepth { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"maxMoveValueDepth" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; maxMoveValueDepth &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: ServiceConfig { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>Transaction { <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>digest { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; digest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Transaction { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>effects ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>effects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"effects" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; effects &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Transaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: TransactionEffects &gt; ; } <span class="kw">pub struct </span>transactionBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>transactionBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"transactionBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; transactionBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Transaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: Transaction { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>TransactionEffects { <span class="kw">pub struct </span>digest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>digest { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"digest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; digest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } <span class="kw">pub struct </span>transaction ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>transaction { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"transaction" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; transaction &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Transaction &gt; ; } <span class="kw">pub struct </span>checkpoint ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>checkpoint { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"checkpoint" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; checkpoint &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Checkpoint &gt; ; } <span class="kw">pub struct </span>effectsBcs ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>effectsBcs { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"effectsBcs" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; effectsBcs &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: Base64 &gt; ; } <span class="kw">pub struct </span>effectsDigest ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>effectsDigest { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"effectsDigest" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; effectsDigest &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; } <span class="kw">pub struct </span>objectChanges ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>objectChanges { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChangeConnection &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"objectChanges" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; objectChanges &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: ObjectChangeConnection &gt; ; } <span class="kw">pub mod </span>_object_changes_arguments { <span class="kw">pub struct </span>first ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; first &gt; <span class="kw">for super </span>:: objectChanges { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"first" </span>; } <span class="kw">pub struct </span>after ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; after &gt; <span class="kw">for super </span>:: objectChanges { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"after" </span>; } <span class="kw">pub struct </span>last ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; last &gt; <span class="kw">for super </span>:: objectChanges { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: Int &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"last" </span>; } <span class="kw">pub struct </span>before ; <span class="kw">impl </span>cynic :: schema :: HasArgument &lt; before &gt; <span class="kw">for super </span>:: objectChanges { <span class="kw">type </span>ArgumentType = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: <span class="kw">super </span>:: String &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"before" </span>; } } <span class="kw">pub struct </span>__typename ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>__typename { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"__typename" </span>; } <span class="kw">impl </span>cynic :: schema :: HasField &lt; __typename &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: TransactionEffects { <span class="kw">type </span>Type = <span class="kw">super </span>:: <span class="kw">super </span>:: String ; } } <span class="kw">pub mod </span>VersionFilter { <span class="kw">pub struct </span>afterVersion ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>afterVersion { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"afterVersion" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; afterVersion , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: VersionFilter { } <span class="kw">pub struct </span>beforeVersion ; <span class="kw">impl </span>cynic :: schema :: Field <span class="kw">for </span>beforeVersion { <span class="kw">type </span>Type = <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; ; <span class="kw">const </span>NAME : &amp; <span class="lifetime">'static </span>:: core :: primitive :: str = <span class="string">"beforeVersion" </span>; } <span class="kw">impl </span>cynic :: schema :: HasInputField &lt; beforeVersion , <span class="prelude-ty">Option</span> &lt; <span class="kw">super </span>:: <span class="kw">super </span>:: UInt53 &gt; &gt; <span class="kw">for super </span>:: <span class="kw">super </span>:: VersionFilter { } } } <span class="kw">pub type </span>Boolean = bool ; <span class="kw">pub type </span>String = std :: string :: String ; <span class="kw">pub type </span>Float = f64 ; <span class="kw">pub type </span>Int = i32 ; <span class="kw">pub type </span>ID = cynic :: Id ; <span class="kw">pub mod </span>variable { <span class="kw">use </span>cynic :: variables :: VariableType ; # [doc = <span class="string">r" Used to determine the type of a given variable that"</span>] # [doc = <span class="string">r" appears in an argument struct."</span>] <span class="kw">pub trait </span>Variable { <span class="kw">const </span>TYPE : VariableType ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>&amp; T <span class="kw">where </span>T : <span class="question-mark">? </span>:: core :: marker :: Sized + Variable , { <span class="kw">const </span>TYPE : VariableType = T :: TYPE ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span><span class="prelude-ty">Option</span> &lt; T &gt; <span class="kw">where </span>T : Variable { <span class="kw">const </span>TYPE : VariableType = VariableType :: Nullable (&amp; T :: TYPE) ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>[T] <span class="kw">where </span>T : Variable , { <span class="kw">const </span>TYPE : VariableType = VariableType :: List (&amp; T :: TYPE) ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>Vec &lt; T &gt; <span class="kw">where </span>T : Variable , { <span class="kw">const </span>TYPE : VariableType = VariableType :: List (&amp; T :: TYPE) ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>Box &lt; T &gt; <span class="kw">where </span>T : Variable , { <span class="kw">const </span>TYPE : VariableType = T :: TYPE ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>std :: rc :: Rc &lt; T &gt; <span class="kw">where </span>T : Variable , { <span class="kw">const </span>TYPE : VariableType = T :: TYPE ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>std :: sync :: Arc &lt; T &gt; <span class="kw">where </span>T : Variable , { <span class="kw">const </span>TYPE : VariableType = T :: TYPE ; } <span class="kw">impl </span>&lt; T &gt; Variable <span class="kw">for </span>std :: borrow :: Cow &lt; <span class="lifetime">'_ </span>, T &gt; <span class="kw">where </span>T : <span class="question-mark">? </span>:: core :: marker :: Sized + Variable + ToOwned , { <span class="kw">const </span>TYPE : VariableType = T :: TYPE ; } <span class="kw">impl </span>Variable <span class="kw">for </span>bool { <span class="kw">const </span>TYPE : VariableType = VariableType :: Named (<span class="string">"Boolean"</span>) ; } <span class="kw">impl </span>Variable <span class="kw">for </span>str { <span class="kw">const </span>TYPE : VariableType = VariableType :: Named (<span class="string">"String"</span>) ; } <span class="kw">impl </span>Variable <span class="kw">for </span>String { <span class="kw">const </span>TYPE : VariableType = &lt; str <span class="kw">as </span>Variable &gt; :: TYPE ; } <span class="kw">impl </span>Variable <span class="kw">for </span>f64 { <span class="kw">const </span>TYPE : VariableType = VariableType :: Named (<span class="string">"Float"</span>) ; } <span class="kw">impl </span>Variable <span class="kw">for </span>i32 { <span class="kw">const </span>TYPE : VariableType = VariableType :: Named (<span class="string">"Int"</span>) ; } <span class="kw">impl </span>Variable <span class="kw">for </span>cynic :: Id { <span class="kw">const </span>TYPE : VariableType = VariableType :: Named (<span class="string">"ID"</span>) ; } }</code></pre></div></section></main></body></html>